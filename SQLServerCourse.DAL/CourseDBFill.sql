INSERT INTO Lessons(Name, LessonType, LectureMarkup) VALUES 
('Введение в MS SQL Server и T-SQL',1,'
    <br />
        MS SQL Server - это система управления базами данных, разработанная и поддерживаемая компанией Microsoft. Она предоставляет средства для хранения,
        управления и обработки данных, а также доступа к ним. В этом уроке мы рассмотрим основные компоненты
        и функции MS SQL Server, а также основы языка T-SQL.
        <br /><br />
        Часть 1: Компоненты MS SQL Server
        <ul>
            <li> SQL Server Database Engine: Это основной компонент MS SQL Server, который обеспечивает функциональность
                управления базами данных, включая создание, изменение и удаление баз данных, таблиц, представлений,
                хранимых процедур и многое другое.</li>
            <li>SQL Server Management Studio (SSMS): Это интегрированная среда разработки, предназначенная для работы с MS SQL Server.
                SSMS позволяет разработчикам управлять базами данных, создавать и выполнять запросы, настраивать 
                безопасность, мониторить работу сервера и многое другое.</li>
            <li>SQL Server Reporting Services (SSRS): SSRS предоставляет средства для создания, управления и распространения отчетов.
                Он позволяет пользователям создавать красочные и информативные отчеты, которые можно представить 
                в различных форматах (например, HTML, PDF, Excel).</li>
            <li>SQL Server Integration Services (SSIS): SSIS предназначен для создания и управления пакетами интеграции данных. 
                Он позволяет разработчикам интегрировать данные из разных источников, проводить их трансформацию 
                и загружать в целевую систему.</li>
        </ul>

        Часть 2: Основы языка T-SQL
        T-SQL (Transact-SQL) - это язык программирования, разработанный для работы с MS SQL Server. Он расширяет стандартный язык запросов SQL, 
        добавляя дополнительные возможности и функции. Вот несколько основных элементов T-SQL:

        Команды DDL (Data Definition Language): Команды DDL используются для создания, изменения и удаления объектов базы данных, 
        таких как таблицы, индексы, представления и т. д. Примеры команд DDL: CREATE TABLE, ALTER TABLE, DROP TABLE.
        Команды DML (Data Manipulation Language): Команды DML используются для манипулирования данными в таблицах базы данных. 
        Они позволяют выполнять операции вставки, обновления и удаления данных. Примеры команд DML: INSERT, UPDATE, DELETE.
        Команды DQL (Data Query Language): Команды DQL используются для извлечения данных из таблиц базы данных. Они позволяют выполнять 
        различные операции выборки и фильтрации данных. Примеры команд DQL: SELECT, FROM, WHERE.
        Хранимые процедуры: Хранимые процедуры - это наборы инструкций T-SQL, которые могут быть сохранены и выполнены в базе данных. 
        Они часто используются для выполнения сложных операций или для повторного использования кода. Хранимые процедуры могут принимать 
        параметры и возвращать результаты.
        Функции: MS SQL Server предоставляет множество встроенных функций, которые могут быть использованы для обработки данных. Некоторые 
        из наиболее часто используемых функций включают функции для работы со строками, датами, числами и т.д.
        <br /><br />
        Основные функции MS SQL Server включают:
        <ol>
            <li>
            Функции агрегации (Aggregate functions): такие как SUM, AVG, MIN, MAX, COUNT и другие, используются для вычисления 
            агрегированных значений в столбцах или результатах запросов.
            </li>
        <li>
            Функции преобразования (Conversion functions): такие как CAST, CONVERT, PARSE и другие, позволяют преобразовывать значения 
            из одного типа данных в другой.
        </li>
        <li>
            Функции строковой обработки (String functions): такие как LEN, UPPER, LOWER, SUBSTRING и другие, используются для работы 
            с текстовыми значениями, их обрезания, объединения и преобразования.
        </li>
        <li>
            Функции даты и времени (Date and Time functions): такие как GETDATE, DATEADD, DATEDIFF и другие, позволяют выполнять 
            операции с датами и временем, такие как добавление или вычитание дня, месяца, часа и других единиц времени.
        </li>
        <li>
            Функции математических вычислений (Mathematical functions): такие как ABS, SQRT, CEILING, FLOOR и другие, используются 
            для выполнения математических операций, например, нахождения абсолютного значения, квадратного корня и округления чисел.
        </li>
        <li>
            Функции условной логики (Conditional functions): такие как CASE, IIF и другие, позволяют выполнить различные 
            действия в зависимости от условий.
        </li>
        <li>
            Функции оконного анализа (Windowing functions): такие как ROW_NUMBER, RANK, DENSE_RANK и другие, позволяют выполнять 
            расчеты по группам строк или окнам и возвращать значения, связанные с текущей строкой.
        </li>
        <li>
            Функции системной информации (System information functions): такие как @@VERSION, SERVERPROPERTY и другие, позволяют
            получать информацию о сервере базы данных и его настройках.
        </li>
        </ol>
        Описывать каждую функцию в этой статье мы не будем, поэтому если при работе с базами данных вам 
        понадобится какая-нибудь из функций, то вы спокойно можете
        зайти на официальный справочник по T-SQL <a href="https://learn.microsoft.com/ru-ru/sql/t-sql/language-reference?view=sql-server-ver16">по вот этой ссылке</a>'),
('Создание и управление базами данных',0,'   
        <br />
    Кратко о MS SQL Server Management Studio (SSMS)<br /><br />

    SQL Server Management Studio (SSMS) — утилита для Microsoft SQL Server для конфигурирования, управления и администрирования компонентов базы данных. 
    Данная утилита содержит редактор скриптов (который в основном и будет нами использоваться) и графическую программу, 
    которая работает с объектами и настройками сервера. Главным инструментом SQL Server Management Studio является Object Explorer, который 
    позволяет пользователю просматривать, извлекать объекты сервера, а также управлять ими. Данный текст частично позаимствован с википедии.
    Для создания нового редактора скрипта используйте кнопку «New Query/Новый запрос»:
        <div><img src="https://habrastorage.org/r/w1560/files/5d0/170/ad0/5d0170ad0847451f904a122af34e0000.png" /></div>
    Для смены текущей базы данных можно использовать выпадающий список:
        <div><img src="https://habrastorage.org/r/w1560/files/618/bc7/1d4/618bc71d4fe44b41a36a71c61436fbb4.png" /></div>
    Для выполнения определенной команды (или группы команд) выделите ее и нажмите кнопку «Execute/Выполнить» или же клавишу «F5». 
    Если в редакторе в текущий момент находится только одна команда, или же вам необходимо выполнить все команды,
    то ничего выделять не нужно.
        <div><img src="https://habrastorage.org/r/w1560/files/a3d/0fb/394/a3d0fb394baf4f7dbe2952954584f888.png" /></div>
    После выполнения скриптов, в особенности создающих объекты (таблицы, столбцы, индексы), чтобы увидеть изменения, используйте обновление из контекстного меню, 
    выделив соответствующую группу (например, Таблицы), саму таблицу или группу Столбцы в ней.
        <div><img src="https://habrastorage.org/r/w1560/files/d59/959/9b0/d599599b0c534d1095a8051a595ff795.png" /></div>
    Собственно, это все, что нам необходимо будет знать для выполнения приведенных здесь примеров. Остальное по утилите SSMS несложно изучить самостоятельно.
    Нередко операция с данными представляет набор инструкций, которые необходимо выполнить в определенной последовательности. Например, при добавлении данных покупки товара
    необходимо внести данные в таблицу заказов. Однако перед этим надо проверить, а есть ли покупаемый товар в наличии. Возможно, при этом понадобится проверить
    еще ряд дополнительных условий. То есть фактически процесс покупки товара охватывает несколько действий, которые должны выполняться в определенной последовательности.
    И в этом случае более оптимально будет инкапсулировать все эти действия в один объект - <b>хранимую процедуру (stored procedure).</b>
    <br /><br />
    То есть по сути хранимые процедуры представляют набор инструкций, которые выполняются как единое целое. Тем самым хранимые процедуры позволяют упростить комплексные операции
    и вынести их в единый объект. Изменится процесс покупки товара, соответственно достаточно будет изменить код процедуры. То есть процедура также упрощает управление кодом.
    Также хранимые процедуры позволяют ограничить доступ к данным в таблицах и тем самым уменьшить вероятность преднамеренных или неосознанных нежелательных действий в отношении
    этих данных. И еще один важный аспект - производительность. Хранимые процедуры обычно выполняются быстрее, чем обычные SQL-инструкции. Все потому что код процедур
    компилируется один раз при первом ее запуске, а затем сохраняется в скомпилированной форме.
    <br /><br />
    Для создания хранимой процедуры применяется команда <b>CREATE PROCEDURE</b> или <b>CREATE PROC</b>.
    <br /><br />
    Хранимая процедура в SQL Server представляет собой группу из одного или нескольких операторов Transact-SQL или ссылку на метод среды CLR Microsoft .NET Framework.
    Процедуры аналогичны конструкциям в других языках программирования, поскольку обеспечивают следующее:
    <ul class="LessonUl">
        <li>обрабатывают входные параметры и возвращают вызывающей программе значения в виде выходных параметров;</li>
        <li>содержат программные инструкции, которые выполняют операции в базе данных, включая вызов других процедур;</li>
        <li>возвращают значение состояния вызывающей программе, таким образом передавая сведения об успешном или неуспешном завершении (и причины последнего).</li>
    </ul>
    <br />
    Преимущества хранимых процедур
    <br /><br />
    В следующем списке описываются преимущества использования процедур.
    <br /><br />
    <ul>
        <li>Снижение сетевого трафика между клиентами и сервером</li>
        <li>Большая безопасность</li>
        <li>
            Предложение EXECUTE AS может быть указано в инструкции CREATE PROCEDURE, чтобы разрешить олицетворение других пользователей или разрешить пользователям или приложениям
            выполнять определенные действия баз данных без необходимости иметь прямые разрешения на базовые объекты и команды.
        </li>
        <li>
            При вызове процедуры через сеть виден только вызов на выполнение процедуры. <br />Таким образом, злоумышленники не могут просматривать имена объектов таблиц и баз данных,
            внедрять собственные инструкции Transact-SQL или выполнять поиск критически важных данных.
        </li>
        <li>
            Использование параметров в процедурах помогает предотвратить атаки типа «инъекция SQL». <br />Так как входные данные параметра обрабатываются как литеральное значение,
            а не как исполняемый код, злоумышленнику сложнее вставить команду в инструкции Transact-SQL внутри процедуры и нарушить безопасность.
        </li>
        <li>Процедуры могут быть зашифрованы, что позволяет замаскировать исходный код. </li>
        <li>
            Повторное использование кода<br />
            Если какой-то код многократно используется в операции базы данных, то отличным решением будет произвести его инкапсуляцию в процедуры.
        </li>
        <li>
            Более легкое обслуживание<br />
            Если клиентские приложения вызывают процедуры, а операции баз данных остаются на уровне данных, то для внесения изменений в основную базу данных будет достаточно обновить
            только процедуры.
        </li>
        <li>
            повышение производительности.<br />
            По умолчанию компиляция процедуры и создание плана выполнения, используемого для последующих выполнений, производится при
            ее первом запуске Поскольку обработчику запросов
            не нужно создавать новый план, обычно обработка процедуры занимает меньше времени.
        </li>
        <li>
            Если в таблицах или данных, на которые ссылается процедура, произошли значительные изменения, то наличие предварительно скомпилированного плана может вызвать замедление
            работы процедуры. В этом случае перекомпиляция процедуры и принудительное создание нового плана выполнения может улучшить производительность.
        </li>
    </ul>
    <br />
    Таким образом, хранимая процедура имеет три ключевых особенности: упрощение кода, безопасность и производительность.
    <br /><br />
    Например, пусть в базе данных есть таблица, которая хранит данные о товарах:
    <br /><br />
    <b>
        CREATE TABLE Products<br />
        (<br />
        Id INT IDENTITY PRIMARY KEY,<br />
        ProductName NVARCHAR(30) NOT NULL,<br />
        Manufacturer NVARCHAR(20) NOT NULL,<br />
        ProductCount INT DEFAULT 0,<br />
        Price MONEY NOT NULL<br />
        );
    </b>
    <br /><br />
    Создадим хранимую процедуру для извлечения данных из этой таблицы:
    <br /><br />
    <b>
        USE productsdb;<br />
        GO<br />
        CREATE PROCEDURE ProductSummary AS<br />
        SELECT ProductName AS Product, Manufacturer, Price<br />
        FROM Products
    </b>
    <br /><br />
    Поскольку команда CREATE PROCEDURE должна вызываться в отдельном пакете, то после команды USE, которая устанавливает текущую базу данных, используется команда GO
    для определения нового пакета. После имени процедуры должно идти ключевое слово AS. Для отделения тела процедуры от остальной части скрипта код процедуры нередко
    помещается в блок BEGIN...END:
    <br /><br />
    <b>
        USE productsdb;<br />
        GO<br />
        CREATE PROCEDURE ProductSummary AS<br />
        BEGIN<br />
        SELECT ProductName AS Product, Manufacturer, Price<br />
        FROM Products<br />
        END;
    </b><br /><br />
    Триггеры sql представляют собой специальный тип хранимых процедур, запускаемых сервером автоматически при изменении данных (DML)
    в таблице, с которой он связан. Триггеры подключаются к определенной таблице. Все производимые триггером изменения данных рассматриваются
    как одна транзакция.
    <br /><br />
    В отличие от обычной хранимой процедуры/функции, триггер вызывается сервером неявно при возникновения определенного триггерного события.
    Кроме этого триггер SQL не имеет аргументов. С помощью триггера решаются следующие задачи :
    <br /><br />
    <ul class="LessonUl">
        <li>
            проверка корректности изменяемых данных и проверка сложных ограничений целостности данных, которые необходимо поддерживать;
        </li>
        <li>
            накопление статистической информации посредством фиксации сведений о внесимых изменениях;
        </li>
        <li>
            поддержка репликации.
        </li>
    </ul>
    <br />
    С помощью ограничений целостности, установленных правил и значений не всегда можно добиться нужного уровня целостности данных.
    Иногда требуется реализовать сложные алгоритмы проверки данных, гарантирующие их достоверность и реальность. Кроме того, часто необходимо
    отслеживать изменения значений таблицы, чтобы нужным образом изменить связанные данные. Триггеры SQL можно рассматривать как своего рода фильтры,
    вступающие в действие после выполнения всех операций в соответствии с правилами, стандартными значениями и т.д.
    <br /><br />
    Применение SQL триггеров связано с дополнительными затратами ресурсов сервера на операции добавления (trigger insert), обновления (trigger update)
    или удаления (trigger delete) данных в таблице.
    <br /><br />
    В том случае, когда тех же результатов можно добиться с помощью хранимых процедур или прикладных программ, применение триггеров нецелесообразно.
    <br /><br />
    Синтаксис создания триггера в СУБД MS SQL имеет следующий вид :
    <br /><br />
    <b>
        CREATE TRIGGER [schema_name.]trigger_name<br />
        ON [table_name | view_name]<br />
        {WITH ENCRYPTION}<br />
        [FOR | AFTER | INSTEAD OF] [[DELETE] [,] [INSERT] [,] [UPDATE]]<br />
        [ WITH APPEND ]<br />
        [ NOT FOR REPLICATION ]<br />
        AS<br />
        {<br />
        sql_statement<br />
        }<br />
        schema_name<br />
    </b>
    <br /><br />
    Наименование схемы триггера DML. Действие триггеров DML ограничивается областью схемы таблицы или представления, для которых они созданы.
    schema_name не может указываться для триггеров DDL или триггеров входа.
    <br /><br />
    trigger_name<br /><br />
    Наименование триггера. Аргумент trigger_name должен соответствовать правилам для идентификаторов — за исключением того, что trigger_name
    не может начинаться с символов # или ##.
    <br /><br />
    table_name | view_name
    <br /><br />
    Таблица или представление, к которым подключен триггер.
    <br /><br />
    Для реализации триггера будут созданы две таблицы : test_table, test_log. К таблице test_table будет подключен триггер. При обновлении
    записей в таблице test_table триггер будет регистрировать в таблице test_log результаты изменений. Т.е. триггер будет вызываться по событию update.
    <br /><br />
    Тестовая таблица test_table :
    <br /><br />
    <b>
        create table dbo.test_table (<br />
        id int not null,<br />
        field1 varchar(255) null,<br />
        field2 varchar(255) null,<br />
        constraint pkTestTableID primary key (id)<br />
        );
    </b>
    <br /><br />
    Таблица журналирования test_log :
    <br /><br />
    <b>
        create table dbo.test_log (<br />
        id bigint identity(1,1) not null,<br />
        table_name varchar(50) not null,<br />
        oper varchar(15) not null,<br />
        record_old xml null,<br />
        record_new xml null,<br />
        data datetime null,<br />
        constraint pkTestLogID primary key (id)<br />
        );
    </b>
    <br /><br />
    Триггер обновления данных :
    <br /><br />
    <b>
        — trigger update<br />
        create trigger dbo.trg_test_table_update<br />
        on dbo.test_table for UPDATE<br />
        as<br />
        begin<br />
        set nocount on<br />
        — переменные для хранения старых и новых данных<br />
        declare @@record_new xml;<br />
        declare @@record_old xml;<br />
        — в таблице deleted хранятся
        старые/удаленные данные<br />
        set @@record_old = (SELECT * FROM deleted FOR XML RAW, TYPE);<br />
        — в таблице inserted хранятся измененные (только что созданные) данные<br />
        set @@record_new = (SELECT * FROM inserted FOR XML RAW, TYPE);<br />
        <br />
        if (@@record_new is not null) and (@@record_old is not null)<br />
        begin<br />
        insert into dbo.test_log (table_name, oper, record_old, record_new, data)<br />
        values (''test_table'', ''update'', @@record_old, @@record_new, GETDATE())<br />
        end;<br />
        end;
    </b>
    <br /><br />'),
('Запросы и манипуляции данными',0,' <br />
			<p>
                Введение:
                База данных является центральным компонентом многих приложений, который позволяет хранить и манипулировать большими объемами данных. Одним из важных аспектов работы с базами данных являются запросы и манипуляции данными. В этом уроке мы рассмотрим различные типы запросов, такие как выборка, сортировка, фильтрация и объединение данных из разных таблиц.
            </p>
            <ol>
                <li>
                    Выборка данных:
                    Выборка данных - это процесс получения информации из базы данных. Для выполнения выборки используется команда SELECT. Пример запроса SELECT:
                </li>
            </ol>
            <p>
                SELECT column1, column2, ...
                FROM table_name;
            </p>
            <p>Этот запрос выберет все значения из указанных столбцов таблицы table_name.</p>
            <ol start="2">
                <li>
                    Сортировка данных:
                    Сортировка данных позволяет упорядочить результаты выборки по определенному столбцу. Для этого используется команда ORDER BY. Примеры запросов с сортировкой:
                </li>
            </ol>
            <p>
                SELECT column1, column2, ...
                FROM table_name
                ORDER BY column1 ASC;
            </p>
            <p>
                SELECT column1, column2, ...
                FROM table_name
                ORDER BY column1 DESC;
            </p>
            <p>Первый запрос сортирует данные по возрастанию значения столбца column1, второй - по убыванию.</p>
            <ol start="3">
                <li>
                    Фильтрация данных:
                    Фильтрация данных позволяет выбрать записи, отвечающие определенным условиям. Для этого используется команда WHERE. Примеры запросов с фильтрацией:
                </li>
            </ol>
            <p>
                SELECT column1, column2, ...
                FROM table_name
                WHERE column1 = value;
            </p>
            <p>
                SELECT column1, column2, ...<br>
                FROM table_name
                WHERE column1 &gt; value;
            </p>
            <p>Первый запрос выберет записи, у которых значение в столбце column1 равно value, второй - записи, у которых значение в столбце column1 больше value.</p>
            <ol start="4">
                <li>
                    Объединение данных из разных таблиц:
                    Иногда данные, которые нам нужно получить, распределены по разным таблицам. Для объединения данных из нескольких таблиц используется команда JOIN. Пример запроса с объединением:
                </li>
            </ol>
            <p>
                SELECT column1, column2, ...
                FROM table1
                JOIN table2 ON table1.column1 = table2.column2;
            </p>
            <p>Этот запрос объединит записи из таблиц table1 и table2 по условию, что значения столбца column1 таблицы table1 равны значениям столбца column2 таблицы table2.</p>
            <ol start="5">
                <li>
                    Другие манипуляции с данными:
                    Есть и другие операции, которые можно выполнять с данными в базе данных, такие как вставка, обновление и удаление данных. Для выполнения этих операций используются команды INSERT INTO, UPDATE и DELETE соответственно. Примеры запросов:
                </li>
            </ol>
            <p>
                INSERT INTO table_name (column1, column2, ...)
                VALUES (value1, value2, ...);
            </p>
            <p>
                UPDATE table_name
                SET column1 = new_value1, column2 = new_value2, ...
                WHERE condition;
            </p>
            <p >
                DELETE FROM table_name
                WHERE condition;
            </p>
            <p>Параметры в этих запросах должны быть заменены на конкретные значения.</p>
            <p>
                Заключение:
                Запросы и манипуляции данными - это важные навыки для работы с базами данных. В этом уроке мы рассмотрели основные типы запросов, которые позволяют выбирать, сортировать, фильтровать, объединять и манипулировать данными в базе данных. Вам предлагается попрактиковаться и применить эти знания на практике для работы с вашей собственной базой данных.
            </p>'),
('Оптимизация и обслуживание баз данных',0,'
				<br />

            <img style="width: 40%;" src="https://alexeykalina.github.io/assets/img/2017-11-25/transaction.jpg">


                <p>Думаю, многие из вас работали с транзакциями и представляют, как применить к базе данных консистентную последовательность операций. Сегодня мы узнаем, что происходит с транзакцией, когда мы отправляем ее в СУБД. Мы познакомимся с классической теорией транзакций и тем, какие существуют подходы для формирования корректных расписаний. Кроме того, постараемся связать эту теорию с практикой на примере известной СУБД Microsoft SQL Server. (Сегодня будет много информации, приготовьтесь!)</p>

                <h1 id="сериализуемые-расписания">Сериализуемые расписания</h1>

                <h3 id="транзакции">Транзакции</h3>
                <p>Начнем с определения того, что такое транзакция:</p>

                <p><strong>Транзакция</strong> - это совокупность операций, выполняемых прикладной программой, которые  переводят согласованное состояние базы данных в согласованное, если:</p>
                <ul>
                    <li>отсутствуют помехи со стороны других приложений;</li>
                    <li>транзакция выполнена полностью.</li>
                </ul>

                <p>В MS SQL Server существует 2 типа транзакций:</p>
                <ol>
                    <li><em>Неявные</em> - отдельные операции INSERT, UPDATE или DELETE.</li>
                    <li><em>Явные</em> -  набор операций языка T-SQL, начинающийся с инструкции BEGIN TRANSACTION и заканчивающийся COMMIT или ROLLBACK.</li>
                </ol>
				<br />
				<p> Оператор COMMIT завершает текущую транзакцию и делает все изменения, выполненные в транзакции, постоянными. COMMIT также стирает все точки 
				сохранения в транзакции и снимает блокировки транзакций. Оператор ROLLBACK отменяет работу, выполненную в текущей транзакции;
				это приводит к отбрасыванию всех изменений данных с момента последней COMMIT-а или ROLLBACK-а.</p>
				<br />
                <p>Для примера рассмотрим транзакцию, обновляющую значения сразу в двух таблицах. В результате ее выполнения либо оба значения будут удачно записаны, либо, в случае отката транзакции, не будет записано ни одно.</p>

                <figure>
                    <pre><code data-lang="sql"><span class="k">BEGIN</span> <span class="n">TRANSACTION</span>
<span class="k">UPDATE</span> <span class="n">tbl1</span>
                    <span class="k">SET</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">10</span>
                    <span class="k">WHERE</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">1</span>
                    <span class="n">IF</span> <span class="o">@@</span><span class="n">ERROR</span> <span class="o">&lt;&gt;</span> <span class="mi">0</span>
                    <span class="k">ROLLBACK</span>
<span class="k">UPDATE</span> <span class="n">tbl2</span>
                    <span class="k">SET</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">10</span>
                    <span class="k">WHERE</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">1</span>
                    <span class="n">IF</span> <span class="o">@@</span><span class="n">ERROR</span> <span class="o">&lt;&gt;</span> <span class="mi">0</span>
                    <span class="k">ROLLBACK</span>
<span class="k">COMMIT</span></code></pre>
                </figure>

                <h3 id="аномалии-транзакций">Аномалии транзакций</h3>
                <p>При параллельном выполнении транзакций возникают различные проблемы, связанные с логикой работы с операциями. Рассмотрим наиболее распространенные из них на примерах из SQL сервера:</p>

                <p>1) <em>Потерянное обновление</em>. При обновлении поля двумя транзакциями одно из изменений теряется.</p>

                <table class="tablestyle">
                    <thead>
                        <tr>
                            <th>Транзакция 1</th>
                            <th>Транзакция 2</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>SELECT x FROM tbl WHERE y=1;</td>
                            <td>SELECT x FROM tbl WHERE y=1;</td>
                        </tr>
                        <tr>
                            <td>UPDATE tbl SET x=5 WHERE y=1;</td>
                            <td>&nbsp;</td>
                        </tr>
                        <tr>
                            <td>&nbsp;</td>
                            <td>UPDATE tbl SET x=3 WHERE y=1;</td>
                        </tr>
                    </tbody>
                </table>

                <p>2) <em>Грязное чтение</em>. Чтение данных, полученных в результате действия транзакции, которая после этого откатится.</p>

                <table>
                    <thead>
                        <tr>
                            <th>Транзакция 1</th>
                            <th>Транзакция 2</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>SELECT x FROM tbl WHERE y=1;</td>
                            <td>&nbsp;</td>
                        </tr>
                        <tr>
                            <td>UPDATE tbl SET x=x+1 WHERE y=1;</td>
                            <td>&nbsp;</td>
                        </tr>
                        <tr>
                            <td>&nbsp;</td>
                            <td>SELECT x FROM tbl WHERE y=1;</td>
                        </tr>
                        <tr>
                            <td>ROLLBACK;</td>
                            <td>&nbsp;</td>
                        </tr>
                    </tbody>
                </table>

                <p>3) <em>Неповторяющееся чтение</em>. Возникает, когда в течение одной транзакции при повторном чтении данные оказываются перезаписанными.</p>

                <table>
                    <thead>
                        <tr>
                            <th>Транзакция 1</th>
                            <th>Транзакция 2</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>SELECT x FROM tbl WHERE y=1;</td>
                            <td>SELECT x FROM tbl WHERE y=1;</td>
                        </tr>
                        <tr>
                            <td>UPDATE tbl SET x=x+1 WHERE y=1;</td>
                            <td>&nbsp;</td>
                        </tr>
                        <tr>
                            <td>COMMIT;</td>
                            <td>&nbsp;</td>
                        </tr>
                        <tr>
                            <td>&nbsp;</td>
                            <td>SELECT x FROM tbl WHERE y=1;</td>
                        </tr>
                    </tbody>
                </table>

                <p>4) <em>Фантомное чтение</em>. Отличие от предыдущей аномалии в том, что при повторном чтении одна и та же выборка дает разные множества строк.</p>

                <table>
                    <thead>
                        <tr>
                            <th>Транзакция 1</th>
                            <th>Транзакция 2</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>&nbsp;</td>
                            <td>SELECT SUM(x) FROM tbl;</td>
                        </tr>
                        <tr>
                            <td>INSERT INTO tbl (x, y) VALUES (5, 3);</td>
                            <td>&nbsp;</td>
                        </tr>
                        <tr>
                            <td>&nbsp;</td>
                            <td>SELECT SUM(x) FROM tbl;</td>
                        </tr>
                    </tbody>
                </table>  
				'	)

INSERT INTO Lessons(Name, LessonType)
VALUES ('Экзамен', 2)

INSERT INTO Questions(LessonId, Number, Type, DisplayQuestion, Answer) VALUES
(1,1,0,'Примеры команд DQL это','v_1'),
(1,2,0,'Хранимые процедуры - это','v_3'),
(1,3,0,'Как расшифровывается первая буква в языке T-SQL?','v_1'),
(1,4,1,'Интегрированная среда разработки для работы с СУБД MS SQL Server называется (напишите аббревиатуру):','ssms'),
(1,5,1,'CAST, CONVERT, PARSE это всё функции чего?','преобразование'),
(1,5,1,'CAST, CONVERT, PARSE это всё функции чего?','преобразования'),
(1,6,1,'Как называется (сокращённо) язык запросов, который используется в MS SQL Server?','t-sql'),
(1,6,1,'Как называется (сокращённо) язык запросов, который используется в MS SQL Server?','tsql'),
(2,1,0,'SSMS - это','v_3'),
(2,2,0,'Для создания хранимой процедуры применяется команда:','v_2'),
(2,3,0,'Во что будет оптимально инкапсулировать набор из нескольких действий?','v_3'),
(2,4,1,'Что является главным инструментом SSMS?','object explorer'),
(2,5,1,'Какая команда устанавливает текущую базу данных ','use'),
(2,6,1,'Назовите первое ключевое слово блока отделения тела процедуры от остальной части скрипта','begin'),
(2,7,2,'Вывести список названий всех фильмов, отсортированных по названию в обратном алфавитном порядке:',
'SELECT Name FROM Films ORDER BY Name DESC;'),
(2,8,2,'Вывести список всех билетов на определённый фильм (а именно столбцы Tickets.Id, Tickets.Cost, Screenings.FilmId)
где цена билета больше 160 рублей и FilmId в Screening = 3','SELECT Tickets.Id, Tickets.Cost, Screenings.FilmId 
FROM Tickets 
JOIN Screenings ON Tickets.ScreeningId = Screenings.Id 
WHERE Screenings.FilmId = 3 AND Tickets.Cost > 160 
ORDER BY Screenings.Time ASC; '),
(3,1,0,'Для фильтрации данных по критерию используется ключевое слово:','v_1'),
(3,2,0,'Какая команда позволяет вставить запись в таблицу','v_1'),
(3,3,0,'JOIN используется для:','v_2'),
(3,4,1,'Для выполнения выборки используется команда:','select'),
(3,5,1,'Какая используется команда для сортировки данных?','order by'),
(3,5,1,'Какая используется команда для сортировки данных?','order'),
(3,6,1,'Какое ключевое слово используется для удаления записей из таблицы','delete'),
(3,7,2,'Вывести список всех фильмов (а именно столбцы Films.Name, Screenings.Time), которые предшествуют дате 2021-01-08 на одну неделю: 
(Используйте функцию t-sql DATEADD)',
'SELECT Films.Name, Screenings.Time 
FROM Films 
JOIN Screenings ON Films.Id = Screenings.FilmId 
WHERE Screenings.Time < DATEADD(WEEK, -1, ''2021-01-08'')'),
(3,8,2,' Вывести список всех билетов (а именно столбцы Tickets.Id, Tickets.Cost)
где номер ряда содержит цифру 5 (Используйте функцию TSQL - CHARINDEX) сортируя Tickets.Id в обратном порядке','SELECT Tickets.Id, Tickets.Cost
FROM Tickets 
WHERE CHARINDEX(''5'', CAST(Tickets.COST AS VARCHAR)) > 0 
ORDER BY Tickets.Id DESC;'),
(4,1,0,'Какие типы транзакций есть в MS SQL Server?','v_3'),
(4,2,0,'Какими словами заканчиваются транзакции?','v_2'),
(4,3,0,'Можно ли делать параллельное выполнение транзакций?','v_1'),
(4,4,1,'Совокупность операций, которые переводят согласованное состояние базы данных в несогласованное - это','транзакция'),
(4,4,1,'Совокупность операций, которые переводят согласованное состояние базы данных в несогласованное - это','трансакция'),
(4,5,1,'Какие 2 ключевых слова начинают выполнение транзакции?','begin transaction'),
(4,6,1,'Оператор ___ завершает текущую транзакцию и делает все изменения, выполненные в транзакции, постоянными.','commit'),
(4,7,2,'Вывести список всех фильмов (а именно столбцы Films.Name, Screenings.Id, Screenings.Time), 
которые в Screenings.Time в дне равно 01 (Используйте функцию t-sql DATEADD): 
(Используйте функцию t-sql DAY)',
'SELECT Films.Name, Screenings.Id, Screenings.Time
FROM Films 
JOIN Screenings ON Films.Id = Screenings.FilmId 
WHERE DAY ( Screenings.Time ) = 01'),
(4,8,2,' Вывести список всех фильмов (а именно столбцы Name, Description)
где длина поля Description больше 150 символов (Используйте функцию TSQL - LEN)','SELECT Name, Description
FROM Films
WHERE LEN(Description) > 150'),
(5,1,0,'Как кратко называется средство администрирования для MS SQL Server?','v_2'),
(5,2,0,'Какая системная база данных используется в качестве шаблона для всех баз данных, которые будут создаваться в экземпляре SQL Server?','v_3'),
(5,3,0,'Какая из этих команд выполняет процедуру или скалярную функцию?','v_1'),
(5,4,0,'Какая из этих функций возвращает строку, возникающую в результате объединения двух или более строковых значений в сквозной форме?','v_1'),
(5,5,0,'Продолжите фразу: транзакция — это группа инструкций одной или нескольких баз данных, которые ...........','v_1'),
(5,6,0,'Как можно создать резервную копию базы данных? ','v_2'),
(5,7,1,'С помощью каких двух ключевых слов создается база данных?','create database'),
(5,8,1,'С помощью какого ключевого слова объявляется переменная?','declare'),
(5,9,1,'Оператор ___ завершает текущую транзакцию и делает все изменения, выполненные в транзакции, постоянными.','commit'),
(5,10,1,'Вставьте пропущенное слово: в операторе IF Необязательное ключевое слово ..... позволяет указать альтернативную инструкцию Transact-SQL,
выполняемую в случае, если значение выражения Boolean_expression равно FALSE или NULL.','else'),
(5,11,1,'С помощью каких двух ключевых слов создается триггер','create trigger'),
(5,12,1,'Какими двумя ключевыми словами можно создать хранимую процедуру, помимо CREATE PROCEDURE?','create proc'),
(5,13,2,'Вывести список фильма, который имеет название ''65'' и среднюю стоимость билета на него 
(Вывести следующие столбцы Films.Name, AverageCost), (Используйте GROUP BY и HAVING)',
'SELECT Films.Name, AVG(Tickets.Cost) AS AverageCost 
FROM Films 
JOIN Screenings ON Films.Id = Screenings.FilmId 
JOIN Tickets ON Screenings.Id = Tickets.ScreeningId 
GROUP BY Films.Name
HAVING Films.Name = ''65'';'),
(5,14,2,'Найти все сеансы, прошедшие раньше текущего времени. (Используйте функцию GETDATE() и выведите все столбцы в таблице с помощью *)',
'SELECT *
FROM Screenings
WHERE Time < GETDATE();')

INSERT INTO TestVariants(QuestionId, VariantNumber, Content, IsRight) VALUES
(1,1,'SELECT, FROM, WHERE',1),
(1,2,'CREATE TABLE, ALTER TABLE, DROP TABLE.',0),
(1,3,'INSERT, UPDATE, DELETE',0),
(2,1,'это часть процедурного кода, который выполняется только при наступлении определенного события.',0),
(2,2,'это команда или блок команд (инструкций), которые успешно завершаются как единое целое',0),
(2,3,'наборы инструкций T-SQL, которые могут быть сохранены и выполнены в базе данных',1),
(3,1,'transact',1),
(3,2,'transform',0),
(3,3,'transferred',0),
(9,1,'утилита,предназначенная для создания и управления пакетами интеграции данных.',0),
(9,2,'утилита, которая предоставляет средства для создания, управления и распространения отчетов',0),
(9,3,'утилита для Microsoft SQL Server для администрирования компонентов базы данных',1),
(10,1,'BEGIN PROCEDURE',0),
(10,2,'CREATE PROCEDURE',1),
(10,3,'INIT PROC',0),
(11,1,'в функцию',0),
(11,2,'в запрос',0),
(11,3,'в хранимую процедуру',1),
(17,1,'WHERE',1),
(17,2,'FROM',0),
(17,3,'SELECT',0),
(18,1,'INSERT',1),
(18,2,'CREATE',0),
(18,3,'UPDATE',0),
(19,1,'для создания дополнительного компонента к запросу',0),
(19,2,'для создания подзапроса',1),
(19,3,'для объединения данных из нескольких таблиц',0),
(26,1,'внутренние и внешние',0),
(26,2,'скрытые и нескрытые',0),
(26,3,'явные и неявные',1),
(27,1,'COMMIT или ROLLBACK',0),
(27,2,'END',1),
(27,3,'EXECUTE или GO',0),
(28,1,'Да, без нагрузок на производительность',1),
(28,2,'Нет, из-за того что они одна единица работы их нельзя делать параллельно',0),
(28,3,'Да, но из-за этого появятся нагрузки на производительность',0),
(35,1,'SMMS',0),
(35,2,'SSMS',1),
(35,3,'SQMLS',0),
(36,1,'master',0),
(36,2,'tempdb',0),
(36,3,'model',1),
(37,1,'EXECUTE',1),
(37,2,'GO',0),
(37,3,'CHECKPOINT',0),
(38,1,'CONCAT',1),
(38,2,'CONJUCT',0),
(38,3,'ADD',0),
(39,1,'Либо полностью фиксируются, либо полностью откатываются',1),
(39,2,'Только полностью откатываются',0),
(39,3,'Только фиксируются',0),
(40,1,'С помощью скрипта',0),
(40,2,'С помощью графического интерфейса',1),
(40,3,'С помощью репликации базы данных',0)

INSERT INTO Keywords(Word)
VALUES ('select'),
('from'),
('where'),
('group by'),
('having'),
('order by'),
('desc'),
('join'),
('on'),
('asc'),
('dateadd'),
('week'),
('charindex'),
('day'),
('len'),
('avg'),
('getdate()')

INSERT INTO QueryWords(Number, KeywordId, QuestionId)
VALUES (1,1,15),
(2,2,15),(3,6,15),(4,7,15),
(1,1,16),(2,2,16),(3,8,16),
(4,9,16),(5,3,16),(6,6,16),
(7,10,16),(1,1,24),(2,2,24),
(3,8,24),(4,9,24),(5,3,24),
(6,11,24),(7,12,24),(1,1,25),
(2,2,25),(3,3,25),(4,13,25),
(5,6,25),(6,7,25),(1,1,33),
(2,2,33),(3,8,33),(4,9,33),
(5,3,33),(6,14,33),(1,1,34),
(2,2,34),(3,3,34),(4,15,34),
(1,1,47),(2,16,47),(3,2,47),
(4,8,47),(5,9,47),(6,8,47),
(7,9,47),(8,4,47),(9,5,47),
(1,1,48),(2,2,48),(3,3,48),
(4,17,48)


